# Ubuntu 14.04 (Trusty)
#cmake_minimum_required (VERSION 2.8.12.2)
# Centos 7
#cmake_minimum_required (VERSION 2.8.11)
cmake_minimum_required (VERSION 2.8)

project (FlatCC)

#
# NOTE: when changing build options, clean the build using:
#
#   scripts/cleanall.sh
#

option(FLATCC_TEST "enable tests" ON)

option (FLATCC_PORTABLE
    "include extra headers for compilers that do not support certain C11 features" OFF)

# Affects the flatbuffer verify operation. Normally a verify should just
# quickly reject invalid buffers but for troubleshooting, assertions can
# enabled. This requires rebuilding the runtime library and will likely
# break test cases (those that tests that an invalid buffer is invalid).
option (FLATCC_DEBUG_VERIFY
    "assert on verify failure in runtime lib" OFF)

# During development it may not be possible to compile with reflection
# enabled because it depends and code generated by the code being built.
# Normally pregenerated code is included, but it will not work during
# breaking changes. This option can disable the self-referential
# feature.
option (FLATCC_REFLECTION
    "generation of binary flatbuffer schema files" ON)

# FLATCC_NATIVE_OPTIM and FLATCC_FAST_DOUBLE affects json parsing,
# especially if the content is pretty printed. But it is plenty
# fast without these settings in most cases.

option (FLATCC_NATIVE_OPTIM
    "use machine native optimizations like SSE 4.2" OFF)

option (FLATCC_FAST_DOUBLE
    "faster but slightly incorrect floating point parser (json)" OFF)

option (FLATCC_IGNORE_CONST_COND "silence const condition warnings" OFF)

# -Werror is only set for some compiler versions that are believed to
# to not generate any warnings. If the assumption breaks, disable
# this option if the warning is not significant.
option (FLATCC_ALLOW_WERROR "allow -Werror to be configured" ON)


if (FLATCC_TEST)
    enable_testing()
endif()

if (FLATCC_DEBUG_VERIFY)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DFLATCC_DEBUG_VERIFY=1")
endif()

if (FLATCC_REFLECTION)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DFLATCC_REFLECTION=1")
    file(WRITE ${PROJECT_SOURCE_DIR}/build/reflection_enabled "REFLECTION=1")
    file(REMOVE ${PROJECT_SOURCE_DIR}/build/reflection_disabled)
else()
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DFLATCC_REFLECTION=0")
    file(REMOVE ${PROJECT_SOURCE_DIR}/build/reflection_enabled)
    file(WRITE ${PROJECT_SOURCE_DIR}/build/reflection_disabled "REFLECTION=0")
endif()

if (FLATCC_NATIVE_OPTIM)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -march=native -DFLATCC_USE_SSE4_2=1")
endif()

if (FLATCC_FAST_DOUBLE)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DGRISU3_PARSE_ALLOW_ERROR -DFLATCC_USE_GRISU3=1")
endif()


# The folder of this directory, as apposed to CMAKE_BINARY_DIR
# which would usually be the build/Release and build/Debug paths
set (dist_dir "${PROJECT_SOURCE_DIR}")
# set (dist_dir "${CMAKE_BINARY_DIR}")

# The targets we copy to bin and lib directories, i.e. not tests.
set(dist_targets
    flatcc
    flatccrt
    flatcc_cli
)

# Note: for compiling generated C code, warnings of unused functions
# and constants should be turned off - those are plentiful. They are
# silenced for Clang, GCC and MSVC in generated headers.headers.

if (CMAKE_C_COMPILER_ID MATCHES "Clang")
    # Clang or AppleClang

    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c11 -pedantic -Wall -Wextra")
    if (FLATCC_ALLOW_WERROR)
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Werror")
    endif()
    if (FLATCC_IGNORE_CONST_COND)
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-tautological-constant-out-of-range-compare")
    endif()

    # To get assembly output
    # set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -save-temps")

elseif (CMAKE_C_COMPILER_ID STREQUAL "GNU")
    execute_process(COMMAND ${CMAKE_C_COMPILER} -dumpversion
                    OUTPUT_VARIABLE GCC_VERSION)
    if (GCC_VERSION VERSION_LESS 4.7)
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra")
        # We need stdalign.h
        set(FLATCC_PORTABLE true)
    else()
        # -std=c11 only available as of 4.7
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c11 -pedantic -Wall -Wextra")
        if (FLATCC_ALLOW_WERROR)
            set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Werror")
        endif()
    endif()
    if (FLATCC_IGNORE_CONST_COND)
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-type-limits")
    endif()

    # In gcc 4.8 it is not possible to suppress this warning using
    # #pragma GCC diagnostic ignored "-Wunused-function"
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-unused-function")
    #set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-type-limits")

elseif (CMAKE_C_COMPILER_ID STREQUAL "Intel")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c11 -Wall -Wextra")
elseif (MSVC) # using STREQUAL here conflicts with string interpretation changes in CMake
    # -DFLATCC_PORTABLE also required, but set earlier
    # -W3 is the highest warning level that is reasonable.
    # See include/flatcc/portable/pwarnings.h for disabled warnings.
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -W3 -D_CRT_SECURE_NO_WARNINGS")
    # MSVC 2013 (1800) supports inline variable declations
    # while MSVC 2010 (1600) does not.
    if (MSVC_VERSION STRLESS "1800")
        # Disables monster sample build which uses C99 style variable decls.
        set (FLATCC_NEED_C89_VAR_DECLS true)
    endif()
    set(FLATCC_PORTABLE true)
else()
    # Best effort
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")
    set(FLATCC_PORTABLE true)
endif()

if (FLATCC_PORTABLE)
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DFLATCC_PORTABLE")
endif()

if (CLANG_VERSION)
    message(STATUS "CLANG_VERSION: ${CLANG_VERSION}")
endif()
if (GCC_VERSION)
    message(STATUS "GCC_VERSION: ${GCC_VERSION}")
endif()
message(STATUS "Configured C_FLAGS: ${CMAKE_C_FLAGS}")

# If enabled the runtime librarys verifier will print an error message
# before asserting on error, otherwise it will just return an error code
# like release builds.
#set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DFLATCC_DEBUG_VERIFY")

set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

set(CMAKE_DEBUG_POSTFIX "_d")

if (CMAKE_BUILD_TYPE MATCHES "Debug")
    set(CMAKE_EXECUTABLE_SUFFIX "_d${CMAKE_EXECUTABLE_SUFFIX}")
endif()

# Note: test cases (except test_cgen) are not built here. They run by
# bash script each time the test fires and triggers thsi build as well.
# These scripts respect the CC env. variable.

add_subdirectory(test)
add_subdirectory(src/compiler)
add_subdirectory(src/runtime)
add_subdirectory(src/cli)
add_subdirectory(samples)

set_target_properties(${dist_targets}
    PROPERTIES
    ARCHIVE_OUTPUT_DIRECTORY "${dist_dir}/lib"
    LIBRARY_OUTPUT_DIRECTORY "${dist_dir}/lib"
    RUNTIME_OUTPUT_DIRECTORY "${dist_dir}/bin"
)
