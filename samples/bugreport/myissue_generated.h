#ifndef FLATBUFFERS_COMMON_READER_H
#define FLATBUFFERS_COMMON_READER_H

/* Generated by flatcc 0.5.0-pre FlatBuffers schema compiler for C by dvide.com */

/* Common FlatBuffers read functionality for C. */

#define PDIAGNOSTIC_IGNORE_UNUSED
#include "flatcc/portable/pdiagnostic_push.h"
#include "flatcc/flatcc_flatbuffers.h"


#define __flatbuffers_read_scalar_at_byteoffset(N, p, o) N ## _read_from_pe((uint8_t *)(p) + (o))
#define __flatbuffers_read_scalar(N, p) N ## _read_from_pe(p)
#define __flatbuffers_read_vt(ID, offset, t)\
flatbuffers_voffset_t offset = 0;\
{   flatbuffers_voffset_t id, *vt;\
    assert(t != 0 && "null pointer table access");\
    id = ID;\
    vt = (flatbuffers_voffset_t *)((uint8_t *)(t) -\
        __flatbuffers_soffset_read_from_pe(t));\
    if (__flatbuffers_voffset_read_from_pe(vt) >= sizeof(vt[0]) * (id + 3)) {\
        offset = __flatbuffers_voffset_read_from_pe(vt + id + 2);\
    }\
}
#define __flatbuffers_field_present(ID, t) { __flatbuffers_read_vt(ID, offset, t) return offset != 0; }
#define __flatbuffers_union_type_field(ID, t)\
{\
    __flatbuffers_read_vt(ID, offset, t)\
    return offset ? __flatbuffers_read_scalar_at_byteoffset(__flatbuffers_utype, t, offset) : 0;\
}
#define __flatbuffers_define_union_field(ID, N, NK, r)\
static inline flatbuffers_utype_t N ## _ ## NK ## _type(N ## _table_t t)\
__flatbuffers_union_type_field(((ID) - 1), t)\
static inline flatbuffers_generic_table_t N ## _ ## NK(N ## _table_t t)\
__flatbuffers_table_field(flatbuffers_generic_table_t, ID, t, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t)\
__flatbuffers_field_present(ID, t)
#define __flatbuffers_define_scalar_field(ID, N, NK, TK, T, V)\
static inline T N ## _ ## NK (N ## _table_t t)\
{ __flatbuffers_read_vt(ID, offset, t)\
  return offset ? __flatbuffers_read_scalar_at_byteoffset(TK, t, offset) : V;\
}\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t)\
__flatbuffers_field_present(ID, t)\
__flatbuffers_define_scan_by_scalar_field(N, NK, T)
#define __flatbuffers_struct_field(T, ID, t, r)\
{\
    __flatbuffers_read_vt(ID, offset, t)\
    if (offset) {\
        return (T)((uint8_t *)(t) + offset);\
    }\
    assert(!(r) && "required field missing");\
    return 0;\
}
#define __flatbuffers_offset_field(T, ID, t, r, adjust)\
{\
    flatbuffers_uoffset_t *elem;\
    __flatbuffers_read_vt(ID, offset, t)\
    if (offset) {\
        elem = (flatbuffers_uoffset_t *)((uint8_t *)(t) + offset);\
        /* Add sizeof so C api can have raw access past header field. */\
        return (T)((uint8_t *)(elem) + adjust +\
              __flatbuffers_uoffset_read_from_pe(elem));\
    }\
    assert(!(r) && "required field missing");\
    return 0;\
}
#define __flatbuffers_vector_field(T, ID, t, r) __flatbuffers_offset_field(T, ID, t, r, sizeof(flatbuffers_uoffset_t))
#define __flatbuffers_table_field(T, ID, t, r) __flatbuffers_offset_field(T, ID, t, r, 0)
#define __flatbuffers_define_struct_field(ID, N, NK, T, r)\
static inline T N ## _ ## NK(N ## _table_t t)\
__flatbuffers_struct_field(T, ID, t, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t)\
__flatbuffers_field_present(ID, t)
#define __flatbuffers_define_vector_field(ID, N, NK, T, r)\
static inline T N ## _ ## NK(N ## _table_t t)\
__flatbuffers_vector_field(T, ID, t, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t)\
__flatbuffers_field_present(ID, t)
#define __flatbuffers_define_table_field(ID, N, NK, T, r)\
static inline T N ## _ ## NK(N ## _table_t t)\
__flatbuffers_table_field(T, ID, t, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t)\
__flatbuffers_field_present(ID, t)
#define __flatbuffers_define_string_field(ID, N, NK, r)\
static inline flatbuffers_string_t N ## _ ## NK(N ## _table_t t)\
__flatbuffers_vector_field(flatbuffers_string_t, ID, t, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t)\
__flatbuffers_field_present(ID, t)\
__flatbuffers_define_scan_by_string_field(N, NK)
#define __flatbuffers_vec_len(vec)\
{ return (vec) ? (size_t)__flatbuffers_uoffset_read_from_pe((flatbuffers_uoffset_t *)vec - 1) : 0; }
#define __flatbuffers_string_len(s) __flatbuffers_vec_len(s)
static inline size_t flatbuffers_vec_len(const void *vec)
__flatbuffers_vec_len(vec)
#define __flatbuffers_scalar_vec_at(N, vec, i)\
{ assert(flatbuffers_vec_len(vec) > (i) && "index out of range");\
  return __flatbuffers_read_scalar(N, &(vec)[i]); }
#define __flatbuffers_struct_vec_at(vec, i)\
{ assert(flatbuffers_vec_len(vec) > (i) && "index out of range"); return (vec) + (i); }
/* `adjust` skips past the header for string vectors. */
#define __flatbuffers_offset_vec_at(T, vec, i, adjust)\
{ const flatbuffers_uoffset_t *elem = (vec) + (i);\
  assert(flatbuffers_vec_len(vec) > (i) && "index out of range");\
  return (T)((uint8_t *)(elem) + (size_t)__flatbuffers_uoffset_read_from_pe(elem) + adjust); }
#define __flatbuffers_define_scalar_vec_len(N) \
static inline size_t N ## _vec_len(N ##_vec_t vec)\
{ return flatbuffers_vec_len(vec); }
#define __flatbuffers_define_scalar_vec_at(N, T) \
static inline T N ## _vec_at(N ## _vec_t vec, size_t i)\
__flatbuffers_scalar_vec_at(N, vec, i)
typedef const char *flatbuffers_string_t;
static inline size_t flatbuffers_string_len(flatbuffers_string_t s)
__flatbuffers_string_len(s)
typedef const flatbuffers_uoffset_t *flatbuffers_string_vec_t;
typedef flatbuffers_uoffset_t *flatbuffers_string_mutable_vec_t;
static inline size_t flatbuffers_string_vec_len(flatbuffers_string_vec_t vec)
__flatbuffers_vec_len(vec)
static inline flatbuffers_string_t flatbuffers_string_vec_at(flatbuffers_string_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(flatbuffers_string_t, vec, i, sizeof(vec[0]))
typedef const void *flatbuffers_generic_table_t;
#include <string.h>
static size_t flatbuffers_not_found = (size_t)-1;
static size_t flatbuffers_end = (size_t)-1;
#define __flatbuffers_identity(n) (n)
#define __flatbuffers_min(a, b) ((a) < (b) ? (a) : (b))
/* Subtraction doesn't work for unsigned types. */
#define __flatbuffers_scalar_cmp(x, y, n) ((x) < (y) ? -1 : (x) > (y))
static inline int __flatbuffers_string_n_cmp(flatbuffers_string_t v, const char *s, size_t n)
{ size_t nv = flatbuffers_string_len(v); int x = strncmp(v, s, nv < n ? nv : n);
  return x != 0 ? x : nv < n ? -1 : nv > n; }
/* `n` arg unused, but needed by string find macro expansion. */
static inline int __flatbuffers_string_cmp(flatbuffers_string_t v, const char *s, size_t n) { (void)n; return strcmp(v, s); }
/* A = identity if searching scalar vectors rather than key fields. */
/* Returns lowest matching index or not_found. */
#define __flatbuffers_find_by_field(A, V, E, L, K, Kn, T, D)\
{ T v; size_t a = 0, b, m; if (!(b = L(V))) { return flatbuffers_not_found; }\
  --b;\
  while (a < b) {\
    m = a + ((b - a) >> 1);\
    v = A(E(V, m));\
    if ((D(v, (K), (Kn))) < 0) {\
      a = m + 1;\
    } else {\
      b = m;\
    }\
  }\
  if (a == b) {\
    v = A(E(V, a));\
    if (D(v, (K), (Kn)) == 0) {\
       return a;\
    }\
  }\
  return flatbuffers_not_found;\
}
#define __flatbuffers_find_by_scalar_field(A, V, E, L, K, T)\
__flatbuffers_find_by_field(A, V, E, L, K, 0, T, __flatbuffers_scalar_cmp)
#define __flatbuffers_find_by_string_field(A, V, E, L, K)\
__flatbuffers_find_by_field(A, V, E, L, K, 0, flatbuffers_string_t, __flatbuffers_string_cmp)
#define __flatbuffers_find_by_string_n_field(A, V, E, L, K, Kn)\
__flatbuffers_find_by_field(A, V, E, L, K, Kn, flatbuffers_string_t, __flatbuffers_string_n_cmp)
#define __flatbuffers_define_find_by_scalar_field(N, NK, TK)\
static inline size_t N ## _vec_find_by_ ## NK(N ## _vec_t vec, TK key)\
__flatbuffers_find_by_scalar_field(N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, key, TK)
#define __flatbuffers_define_scalar_find(N, T)\
static inline size_t N ## _vec_find(N ## _vec_t vec, T key)\
__flatbuffers_find_by_scalar_field(__flatbuffers_identity, vec, N ## _vec_at, N ## _vec_len, key, T)
#define __flatbuffers_define_find_by_string_field(N, NK) \
/* Note: find only works on vectors sorted by this field. */\
static inline size_t N ## _vec_find_by_ ## NK(N ## _vec_t vec, const char *s)\
__flatbuffers_find_by_string_field(N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s)\
static inline size_t N ## _vec_find_n_by_ ## NK(N ## _vec_t vec, const char *s, int n)\
__flatbuffers_find_by_string_n_field(N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s, n)
#define __flatbuffers_define_default_find_by_scalar_field(N, NK, TK)\
static inline size_t N ## _vec_find(N ## _vec_t vec, TK key)\
{ return N ## _vec_find_by_ ## NK(vec, key); }
#define __flatbuffers_define_default_find_by_string_field(N, NK) \
static inline size_t N ## _vec_find(N ## _vec_t vec, const char *s)\
{ return N ## _vec_find_by_ ## NK(vec, s); }\
static inline size_t N ## _vec_find_n(N ## _vec_t vec, const char *s, int n)\
{ return N ## _vec_find_n_by_ ## NK(vec, s, n); }
/* A = identity if searching scalar vectors rather than key fields. */
/* Returns lowest matching index or not_found. */
#define __flatbuffers_scan_by_field(b, e, A, V, E, L, K, Kn, T, D)\
{ T v; size_t i;\
  for (i = b; i < e; ++i) {\
    v = A(E(V, i));\
    if (D(v, (K), (Kn)) == 0) {\
       return i;\
    }\
  }\
  return flatbuffers_not_found;\
}
#define __flatbuffers_rscan_by_field(b, e, A, V, E, L, K, Kn, T, D)\
{ T v; size_t i = e;\
  while (i-- > b) {\
    v = A(E(V, i));\
    if (D(v, (K), (Kn)) == 0) {\
       return i;\
    }\
  }\
  return flatbuffers_not_found;\
}
#define __flatbuffers_scan_by_scalar_field(b, e, A, V, E, L, K, T)\
__flatbuffers_scan_by_field(b, e, A, V, E, L, K, 0, T, __flatbuffers_scalar_cmp)
#define __flatbuffers_scan_by_string_field(b, e, A, V, E, L, K)\
__flatbuffers_scan_by_field(b, e, A, V, E, L, K, 0, flatbuffers_string_t, __flatbuffers_string_cmp)
#define __flatbuffers_scan_by_string_n_field(b, e, A, V, E, L, K, Kn)\
__flatbuffers_scan_by_field(b, e, A, V, E, L, K, Kn, flatbuffers_string_t, __flatbuffers_string_n_cmp)
#define __flatbuffers_rscan_by_scalar_field(b, e, A, V, E, L, K, T)\
__flatbuffers_rscan_by_field(b, e, A, V, E, L, K, 0, T, __flatbuffers_scalar_cmp)
#define __flatbuffers_rscan_by_string_field(b, e, A, V, E, L, K)\
__flatbuffers_rscan_by_field(b, e, A, V, E, L, K, 0, flatbuffers_string_t, __flatbuffers_string_cmp)
#define __flatbuffers_rscan_by_string_n_field(b, e, A, V, E, L, K, Kn)\
__flatbuffers_rscan_by_field(b, e, A, V, E, L, K, Kn, flatbuffers_string_t, __flatbuffers_string_n_cmp)
#define __flatbuffers_define_scan_by_scalar_field(N, NK, T)\
static inline size_t N ## _vec_scan_by_ ## NK(N ## _vec_t vec, T key)\
__flatbuffers_scan_by_scalar_field(0, N ## _vec_len(vec), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, key, T)\
static inline size_t N ## _vec_scan_ex_by_ ## NK(N ## _vec_t vec, size_t begin, size_t end, T key)\
__flatbuffers_scan_by_scalar_field(begin, __flatbuffers_min(end, N ## _vec_len(vec)), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, key, T)\
static inline size_t N ## _vec_rscan_by_ ## NK(N ## _vec_t vec, T key)\
__flatbuffers_rscan_by_scalar_field(0, N ## _vec_len(vec), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, key, T)\
static inline size_t N ## _vec_rscan_ex_by_ ## NK(N ## _vec_t vec, size_t begin, size_t end, T key)\
__flatbuffers_rscan_by_scalar_field(begin, __flatbuffers_min(end, N ## _vec_len(vec)), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, key, T)
#define __flatbuffers_define_scalar_scan(N, T)\
static inline size_t N ## _vec_scan(N ## _vec_t vec, T key)\
__flatbuffers_scan_by_scalar_field(0, N ## _vec_len(vec), __flatbuffers_identity, vec, N ## _vec_at, N ## _vec_len, key, T)\
static inline size_t N ## _vec_scan_ex(N ## _vec_t vec, size_t begin, size_t end, T key)\
__flatbuffers_scan_by_scalar_field(begin, __flatbuffers_min(end, N ## _vec_len(vec)), __flatbuffers_identity, vec, N ## _vec_at, N ## _vec_len, key, T)\
static inline size_t N ## _vec_rscan(N ## _vec_t vec, T key)\
__flatbuffers_rscan_by_scalar_field(0, N ## _vec_len(vec), __flatbuffers_identity, vec, N ## _vec_at, N ## _vec_len, key, T)\
static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec, size_t begin, size_t end, T key)\
__flatbuffers_rscan_by_scalar_field(begin, __flatbuffers_min(end, N ## _vec_len(vec)), __flatbuffers_identity, vec, N ## _vec_at, N ## _vec_len, key, T)
#define __flatbuffers_define_scan_by_string_field(N, NK) \
static inline size_t N ## _vec_scan_by_ ## NK(N ## _vec_t vec, const char *s)\
__flatbuffers_scan_by_string_field(0, N ## _vec_len(vec), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s)\
static inline size_t N ## _vec_scan_n_by_ ## NK(N ## _vec_t vec, const char *s, int n)\
__flatbuffers_scan_by_string_n_field(0, N ## _vec_len(vec), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s, n)\
static inline size_t N ## _vec_scan_ex_by_ ## NK(N ## _vec_t vec, size_t begin, size_t end, const char *s)\
__flatbuffers_scan_by_string_field(begin, __flatbuffers_min(end, N ## _vec_len(vec)), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s)\
static inline size_t N ## _vec_scan_ex_n_by_ ## NK(N ## _vec_t vec, size_t begin, size_t end, const char *s, int n)\
__flatbuffers_scan_by_string_n_field(begin, __flatbuffers_min( end, N ## _vec_len(vec) ), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s, n)\
static inline size_t N ## _vec_rscan_by_ ## NK(N ## _vec_t vec, const char *s)\
__flatbuffers_rscan_by_string_field(0, N ## _vec_len(vec), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s)\
static inline size_t N ## _vec_rscan_n_by_ ## NK(N ## _vec_t vec, const char *s, int n)\
__flatbuffers_rscan_by_string_n_field(0, N ## _vec_len(vec), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s, n)\
static inline size_t N ## _vec_rscan_ex_by_ ## NK(N ## _vec_t vec, size_t begin, size_t end, const char *s)\
__flatbuffers_rscan_by_string_field(begin, __flatbuffers_min(end, N ## _vec_len(vec)), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s)\
static inline size_t N ## _vec_rscan_ex_n_by_ ## NK(N ## _vec_t vec, size_t begin, size_t end, const char *s, int n)\
__flatbuffers_rscan_by_string_n_field(begin, __flatbuffers_min( end, N ## _vec_len(vec) ), N ## _ ## NK, vec, N ## _vec_at, N ## _vec_len, s, n)
#define __flatbuffers_define_default_scan_by_scalar_field(N, NK, TK)\
static inline size_t N ## _vec_scan(N ## _vec_t vec, TK key)\
{ return N ## _vec_scan_by_ ## NK(vec, key); }\
static inline size_t N ## _vec_scan_ex(N ## _vec_t vec, size_t begin, size_t end, TK key)\
{ return N ## _vec_scan_ex_by_ ## NK(vec, begin, end, key); }\
static inline size_t N ## _vec_rscan(N ## _vec_t vec, TK key)\
{ return N ## _vec_rscan_by_ ## NK(vec, key); }\
static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec, size_t begin, size_t end, TK key)\
{ return N ## _vec_rscan_ex_by_ ## NK(vec, begin, end, key); }
#define __flatbuffers_define_default_scan_by_string_field(N, NK) \
static inline size_t N ## _vec_scan(N ## _vec_t vec, const char *s)\
{ return N ## _vec_scan_by_ ## NK(vec, s); }\
static inline size_t N ## _vec_scan_n(N ## _vec_t vec, const char *s, int n)\
{ return N ## _vec_scan_n_by_ ## NK(vec, s, n); }\
static inline size_t N ## _vec_scan_ex(N ## _vec_t vec, size_t begin, size_t end, const char *s)\
{ return N ## _vec_scan_ex_by_ ## NK(vec, begin, end, s); }\
static inline size_t N ## _vec_scan_ex_n(N ## _vec_t vec, size_t begin, size_t end, const char *s, int n)\
{ return N ## _vec_scan_ex_n_by_ ## NK(vec, begin, end, s, n); }\
static inline size_t N ## _vec_rscan(N ## _vec_t vec, const char *s)\
{ return N ## _vec_rscan_by_ ## NK(vec, s); }\
static inline size_t N ## _vec_rscan_n(N ## _vec_t vec, const char *s, int n)\
{ return N ## _vec_rscan_n_by_ ## NK(vec, s, n); }\
static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec, size_t begin, size_t end, const char *s)\
{ return N ## _vec_rscan_ex_by_ ## NK(vec, begin, end, s); }\
static inline size_t N ## _vec_rscan_ex_n(N ## _vec_t vec, size_t begin, size_t end, const char *s, int n)\
{ return N ## _vec_rscan_ex_n_by_ ## NK(vec, begin, end, s, n); }
#define __flatbuffers_heap_sort(N, X, A, E, L, TK, TE, D, S)\
static inline void __ ## N ## X ## __heap_sift_down(\
        N ## _mutable_vec_t vec, size_t start, size_t end)\
{ size_t child, root; TK v1, v2, vroot;\
  root = start;\
  while ((root << 1) <= end) {\
    child = root << 1;\
    if (child < end) {\
      v1 = A(E(vec, child));\
      v2 = A(E(vec, child + 1));\
      if (D(v1, v2) < 0) {\
        child++;\
      }\
    }\
    vroot = A(E(vec, root));\
    v1 = A(E(vec, child));\
    if (D(vroot, v1) < 0) {\
      S(vec, root, child, TE);\
      root = child;\
    } else {\
      return;\
    }\
  }\
}\
static inline void __ ## N ## X ## __heap_sort(N ## _mutable_vec_t vec)\
{ size_t start, end, size;\
  size = L(vec); if (size == 0) return; end = size - 1; start = size >> 1;\
  do { __ ## N ## X ## __heap_sift_down(vec, start, end); } while (start--);\
  while (end > 0) { \
    S(vec, 0, end, TE);\
    __ ## N ## X ## __heap_sift_down(vec, 0, --end); } }
#define __flatbuffers_define_sort_by_field(N, NK, TK, TE, D, S)\
  __flatbuffers_heap_sort(N, _sort_by_ ## NK, N ## _ ## NK, N ## _vec_at, N ## _vec_len, TK, TE, D, S)\
static inline void N ## _vec_sort_by_ ## NK(N ## _mutable_vec_t vec)\
{ __ ## N ## _sort_by_ ## NK ## __heap_sort(vec); }
#define __flatbuffers_define_sort(N, TK, TE, D, S)\
__flatbuffers_heap_sort(N, , __flatbuffers_identity, N ## _vec_at, N ## _vec_len, TK, TE, D, S)\
static inline void N ## _vec_sort(N ## _mutable_vec_t vec) { __ ## N ## __heap_sort(vec); }
#define __flatbuffers_scalar_diff(x, y) ((x) < (y) ? -1 : (x) > (y))
#define __flatbuffers_string_diff(x, y) __flatbuffers_string_n_cmp((x), (const char *)(y), flatbuffers_string_len(y))
#define __flatbuffers_scalar_swap(vec, a, b, TE) { TE tmp = vec[b]; vec[b] = vec[a]; vec[a] = tmp; }
#define __flatbuffers_string_swap(vec, a, b, TE)\
{ TE ta, tb, d;\
  d = (TE)((a - b) * sizeof(vec[0]));\
  ta =  __flatbuffers_uoffset_read_from_pe(vec + b) - d;\
  tb =  __flatbuffers_uoffset_read_from_pe(vec + a) + d;\
  __flatbuffers_uoffset_write_to_pe(vec + a, ta);\
  __flatbuffers_uoffset_write_to_pe(vec + b, tb); }
#define __flatbuffers_define_sort_by_scalar_field(N, NK, TK, TE)\
  __flatbuffers_define_sort_by_field(N, NK, TK, TE, __flatbuffers_scalar_diff, __flatbuffers_scalar_swap)
#define __flatbuffers_define_sort_by_string_field(N, NK)\
  __flatbuffers_define_sort_by_field(N, NK, flatbuffers_string_t, flatbuffers_uoffset_t, __flatbuffers_string_diff, __flatbuffers_string_swap)
#define __flatbuffers_define_scalar_sort(N, T) __flatbuffers_define_sort(N, T, T, __flatbuffers_scalar_diff, __flatbuffers_scalar_swap)
#define __flatbuffers_define_string_sort() __flatbuffers_define_sort(flatbuffers_string, flatbuffers_string_t, flatbuffers_uoffset_t, __flatbuffers_string_diff, __flatbuffers_string_swap)
#define __flatbuffers_define_scalar_vector(N, T)\
typedef const T *N ## _vec_t;\
typedef T *N ## _mutable_vec_t;\
__flatbuffers_define_scalar_vec_len(N)\
__flatbuffers_define_scalar_vec_at(N, T)\
__flatbuffers_define_scalar_find(N, T)\
__flatbuffers_define_scalar_scan(N, T)\
__flatbuffers_define_scalar_sort(N, T)

#define __flatbuffers_define_integer_type(N, T, W)\
__flatcc_define_integer_accessors(N, T, W, flatbuffers_endian)\
__flatbuffers_define_scalar_vector(N, T)
__flatbuffers_define_scalar_vector(flatbuffers_bool, flatbuffers_bool_t)
__flatbuffers_define_scalar_vector(flatbuffers_uint8, uint8_t)
__flatbuffers_define_scalar_vector(flatbuffers_int8, int8_t)
__flatbuffers_define_scalar_vector(flatbuffers_uint16, uint16_t)
__flatbuffers_define_scalar_vector(flatbuffers_int16, int16_t)
__flatbuffers_define_scalar_vector(flatbuffers_uint32, uint32_t)
__flatbuffers_define_scalar_vector(flatbuffers_int32, int32_t)
__flatbuffers_define_scalar_vector(flatbuffers_uint64, uint64_t)
__flatbuffers_define_scalar_vector(flatbuffers_int64, int64_t)
__flatbuffers_define_scalar_vector(flatbuffers_float, float)
__flatbuffers_define_scalar_vector(flatbuffers_double, double)
static inline size_t flatbuffers_string_vec_find(flatbuffers_string_vec_t vec, const char *s)
__flatbuffers_find_by_string_field(__flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_find_n(flatbuffers_string_vec_t vec, const char *s, size_t n)
__flatbuffers_find_by_string_n_field(__flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_scan(flatbuffers_string_vec_t vec, const char *s)
__flatbuffers_scan_by_string_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_scan_n(flatbuffers_string_vec_t vec, const char *s, size_t n)
__flatbuffers_scan_by_string_n_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_scan_ex(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s)
__flatbuffers_scan_by_string_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_scan_ex_n(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s, size_t n)
__flatbuffers_scan_by_string_n_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_rscan(flatbuffers_string_vec_t vec, const char *s)
__flatbuffers_rscan_by_string_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_rscan_n(flatbuffers_string_vec_t vec, const char *s, size_t n)
__flatbuffers_rscan_by_string_n_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_rscan_ex(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s)
__flatbuffers_rscan_by_string_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_rscan_ex_n(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s, size_t n)
__flatbuffers_rscan_by_string_n_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
__flatbuffers_define_string_sort()
#define __flatbuffers_define_struct_scalar_field(N, NK, TK, T)\
static inline T N ## _ ## NK (N ## _struct_t t)\
{ return t ? __flatbuffers_read_scalar(TK, &(t->NK)) : 0; }\
__flatbuffers_define_scan_by_scalar_field(N, NK, T)
#define __flatbuffers_define_struct_struct_field(N, NK, T)\
static inline T N ## _ ## NK(N ## _struct_t t) { return t ? &(t->NK) : 0; }
/* If fid is null, the function returns true without testing as buffer is not expected to have any id. */
static inline int flatbuffers_has_identifier(const void *buffer, const char *fid)
{ flatbuffers_thash_t id, id2 = 0; if (fid == 0) { return 1; };
  strncpy((char *)&id2, fid, sizeof(id2));
  /* Identifier strings are always considered little endian. */
  id2 = __flatbuffers_thash_cast_from_le(id2);
  id = __flatbuffers_thash_read_from_pe(((flatbuffers_uoffset_t *)buffer) + 1);
  return id2 == 0 || id == id2; }
static inline int flatbuffers_has_type_hash(const void *buffer, flatbuffers_thash_t thash)
{ return thash == 0 || (__flatbuffers_thash_read_from_pe((flatbuffers_uoffset_t *)buffer + 1) == thash); }

static inline flatbuffers_thash_t flatbuffers_get_type_hash(const void *buffer)
{ return __flatbuffers_thash_read_from_pe((flatbuffers_uoffset_t *)buffer + 1); }

#define flatbuffers_verify_endian() flatbuffers_has_identifier("\x00\x00\x00\x00" "1234", "1234")
static inline void *flatbuffers_read_size_prefix(void *b, size_t *size_out)
{ if (size_out) { *size_out = (size_t)__flatbuffers_uoffset_read_from_pe(b); }
  return (uint8_t *)b + sizeof(flatbuffers_uoffset_t); }
/* Null file identifier accepts anything, otherwise fid should be 4 characters. */
#define __flatbuffers_read_root(T, K, buffer, fid)\
  ((!buffer || !flatbuffers_has_identifier(buffer, fid)) ? 0 :\
  ((T ## _ ## K ## t)(((uint8_t *)buffer) +\
    __flatbuffers_uoffset_read_from_pe(buffer))))
#define __flatbuffers_read_typed_root(T, K, buffer, thash)\
  ((!buffer || !flatbuffers_has_type_hash(buffer, thash)) ? 0 :\
  ((T ## _ ## K ## t)(((uint8_t *)buffer) +\
    __flatbuffers_uoffset_read_from_pe(buffer))))
#define __flatbuffers_nested_buffer_as_root(C, N, T, K)\
static inline T ## _ ## K ## t C ## _ ## N ## _as_root_with_identifier(C ## _ ## table_t t, const char *fid)\
{ const uint8_t *buffer = C ## _ ## N(t); return __flatbuffers_read_root(T, K, buffer, fid); }\
static inline T ## _ ## K ## t C ## _ ## N ## _as_typed_root(C ## _ ## table_t t)\
{ const uint8_t *buffer = C ## _ ## N(t); return __flatbuffers_read_root(T, K, buffer, C ## _ ## type_identifier); }\
static inline T ## _ ## K ## t C ## _ ## N ## _as_root(C ## _ ## table_t t)\
{ const char *fid = T ## _identifier;\
  const uint8_t *buffer = C ## _ ## N(t); return __flatbuffers_read_root(T, K, buffer, fid); }
#define __flatbuffers_buffer_as_root(N, K)\
static inline N ## _ ## K ## t N ## _as_root_with_identifier(const void *buffer, const char *fid)\
{ return __flatbuffers_read_root(N, K, buffer, fid); }\
static inline N ## _ ## K ## t N ## _as_root_with_type_hash(const void *buffer, flatbuffers_thash_t thash)\
{ return __flatbuffers_read_typed_root(N, K, buffer, thash); }\
static inline N ## _ ## K ## t N ## _as_root(const void *buffer)\
{ const char *fid = N ## _identifier;\
  return __flatbuffers_read_root(N, K, buffer, fid); }\
static inline N ## _ ## K ## t N ## _as_typed_root(const void *buffer)\
{ return __flatbuffers_read_typed_root(N, K, buffer, N ## _type_hash); }
#define __flatbuffers_struct_as_root(N) __flatbuffers_buffer_as_root(N, struct_)
#define __flatbuffers_table_as_root(N) __flatbuffers_buffer_as_root(N, table_)

#include "flatcc/portable/pdiagnostic_pop.h"
#endif /* FLATBUFFERS_COMMON_H */
#ifndef FLATBUFFERS_COMMON_BUILDER_H
#define FLATBUFFERS_COMMON_BUILDER_H

/* Generated by flatcc 0.5.0-pre FlatBuffers schema compiler for C by dvide.com */

/* Common FlatBuffers build functionality for C. */

#define PDIAGNOSTIC_IGNORE_UNUSED
#include "flatcc/portable/pdiagnostic_push.h"
#ifndef FLATBUILDER_H
#include "flatcc/flatcc_builder.h"
#endif
typedef flatcc_builder_t flatbuffers_builder_t;
typedef flatcc_builder_ref_t flatbuffers_ref_t;
typedef flatcc_builder_ref_t flatbuffers_vec_ref_t;
/* integer return code (ref and ptr always fail on 0) */
#define flatbuffers_failed(x) ((x) < 0)
typedef flatbuffers_ref_t flatbuffers_root_t;
#define flatbuffers_root(ref) ((flatbuffers_root_t)(ref))

#define __flatbuffers_build_buffer(NS)\
typedef NS ## ref_t NS ## buffer_ref_t;\
static inline int NS ## buffer_start(NS ## builder_t *B, const NS ##fid_t fid)\
{ return flatcc_builder_start_buffer(B, fid, 0, 0); }\
static inline int NS ## buffer_start_with_size(NS ## builder_t *B, const NS ##fid_t fid)\
{ return flatcc_builder_start_buffer(B, fid, 0, flatcc_builder_with_size); }\
static inline int NS ## buffer_start_aligned(NS ## builder_t *B, NS ##fid_t fid, uint16_t block_align)\
{ return flatcc_builder_start_buffer(B, fid, block_align, 0); }\
static inline int NS ## buffer_start_aligned_with_size(NS ## builder_t *B, NS ##fid_t fid, uint16_t block_align)\
{ return flatcc_builder_start_buffer(B, fid, block_align, flatcc_builder_with_size); }\
static inline NS ## buffer_ref_t NS ## buffer_end(NS ## builder_t *B, NS ## ref_t root)\
{ return flatcc_builder_end_buffer(B, root); }

#define __flatbuffers_build_table_root(NS, N, FID, TFID)\
static inline int N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? -1 : N ## _start(B); }\
static inline int N ## _start_as_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, FID) ? -1 : N ## _start(B); }\
static inline int N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, TFID) ? -1 : N ## _start(B); }\
static inline int N ## _start_as_typed_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, TFID) ? -1 : N ## _start(B); }\
static inline NS ## buffer_ref_t N ## _end_as_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _end_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _create_as_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start(B, FID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }\
static inline NS ## buffer_ref_t N ## _create_as_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start_with_size(B, FID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start(B, TFID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start_with_size(B, TFID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }

#define __flatbuffers_build_table_prolog(NS, N, FID, TFID)\
__flatbuffers_build_table_vector_ops(NS, N ## _vec, N)\
__flatbuffers_build_table_root(NS, N, FID, TFID)

#define __flatbuffers_build_struct_root(NS, N, A, FID, TFID)\
static inline N ## _t *N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? 0 : N ## _start(B); }\
static inline N ## _t *N ## _start_as_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, FID) ? 0 : N ## _start(B); }\
static inline N ## _t *N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, TFID) ? 0 : N ## _start(B); }\
static inline N ## _t *N ## _start_as_typed_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, TFID) ? 0 : N ## _start(B); }\
static inline NS ## buffer_ref_t N ## _end_as_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _end_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _end_pe_as_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end_pe(B)); }\
static inline NS ## buffer_ref_t N ## _end_pe_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end_pe(B)); }\
static inline NS ## buffer_ref_t N ## _create_as_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, FID, 0,\
  N ## _create(B __ ## N ## _call_args), A, 0); }\
static inline NS ## buffer_ref_t N ## _create_as_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, FID, 0,\
  N ## _create(B __ ## N ## _call_args), A, flatcc_builder_with_size); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, TFID, 0,\
  N ## _create(B __ ## N ## _call_args), A, 0); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, TFID, 0,\
  N ## _create(B __ ## N ## _call_args), A, flatcc_builder_with_size); }

#define __flatbuffers_build_nested_table_root(NS, N, TN, FID, TFID)\
static inline int N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? -1 : TN ## _start(B); }\
static inline int N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, TFID) ? -1 : TN ## _start(B); }\
static inline int N ## _end_as_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _end_as_typed_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align ? align : 8, FLATBUFFERS_COUNT_MAX(1))); }\
static inline int N ## _typed_nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align ? align : 8, FLATBUFFERS_COUNT_MAX(1))); }

#define __flatbuffers_build_nested_struct_root(NS, N, TN, A, FID, TFID)\
static inline TN ## _t *N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? 0 : TN ## _start(B); }\
static inline TN ## _t *N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? 0 : TN ## _start(B); }\
static inline int N ## _end_as_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _end_as_typed_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _end_pe_as_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end_pe(B))); }\
static inline int N ## _create_as_root(NS ## builder_t *B __ ## TN ## _formal_args)\
{ return N ## _add(B, flatcc_builder_create_buffer(B, FID, 0,\
  TN ## _create(B __ ## TN ## _call_args), A, flatcc_builder_is_nested)); }\
static inline int N ## _create_as_typed_root(NS ## builder_t *B __ ## TN ## _formal_args)\
{ return N ## _add(B, flatcc_builder_create_buffer(B, TFID, 0,\
  TN ## _create(B __ ## TN ## _call_args), A, flatcc_builder_is_nested)); }\
static inline int N ## _nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align < A ? A : align, FLATBUFFERS_COUNT_MAX(1))); }\
static inline int N ## _typed_nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align < A ? A : align, FLATBUFFERS_COUNT_MAX(1))); }

#define __flatbuffers_build_vector_ops(NS, V, N, TN, T)\
static inline T *V ## _extend(NS ## builder_t *B, size_t len)\
{ return (T *)flatcc_builder_extend_vector(B, len); }\
static inline T *V ## _append(NS ## builder_t *B, const T *data, size_t len)\
{ return (T *)flatcc_builder_append_vector(B, data, len); }\
static inline int V ## _truncate(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_truncate_vector(B, len); }\
static inline T *V ## _edit(NS ## builder_t *B)\
{ return (T *)flatcc_builder_vector_edit(B); }\
static inline size_t V ## _reserved_len(NS ## builder_t *B)\
{ return flatcc_builder_vector_count(B); }\
static inline T *V ## _push(NS ## builder_t *B, const T *p)\
{ T *_p; return (_p = (T *)flatcc_builder_extend_vector(B, 1)) ? (memcpy(_p, p, TN ## __size()), _p) : 0; }\
static inline T *V ## _push_copy(NS ## builder_t *B, const T *p)\
{ T *_p; return (_p = (T *)flatcc_builder_extend_vector(B, 1)) ? TN ## _copy(_p, p) : 0; }\
static inline T *V ## _push_create(NS ## builder_t *B __ ## TN ## _formal_args)\
{ T *_p; return (_p = (T *)flatcc_builder_extend_vector(B, 1)) ? TN ## _assign(_p __ ## TN ## _call_args) : 0; }

#define __flatbuffers_build_vector(NS, N, T, S, A)\
typedef NS ## ref_t N ## _vec_ref_t;\
static inline int N ## _vec_start(NS ## builder_t *B)\
{ return flatcc_builder_start_vector(B, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
static inline N ## _vec_ref_t N ## _vec_end_pe(NS ## builder_t *B)\
{ return flatcc_builder_end_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_end(NS ## builder_t *B)\
{ if (!NS ## is_native_pe()) { size_t i, n; T *p = (T *)flatcc_builder_vector_edit(B);\
    for (i = 0, n = flatcc_builder_vector_count(B); i < n; ++i)\
    { N ## _to_pe(N ## __ptr_add(p, i)); }} return flatcc_builder_end_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_create_pe(NS ## builder_t *B, const T *data, size_t len)\
{ return flatcc_builder_create_vector(B, data, len, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
static inline N ## _vec_ref_t N ## _vec_create(NS ## builder_t *B, const T *data, size_t len)\
{ if (!NS ## is_native_pe()) { size_t i; T *p; int ret = flatcc_builder_start_vector(B, S, A, FLATBUFFERS_COUNT_MAX(S)); if (ret) { return ret; }\
  p = (T *)flatcc_builder_extend_vector(B, len); if (!p) return 0;\
  for (i = 0; i < len; ++i) { N ## _copy_to_pe(N ## __ptr_add(p, i), N ## __const_ptr_add(data, i)); }\
  return flatcc_builder_end_vector(B); } else return flatcc_builder_create_vector(B, data, len, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
static inline N ## _vec_ref_t N ## _vec_clone(NS ## builder_t *B, N ##_vec_t vec)\
{ return flatcc_builder_create_vector(B, vec, N ## _vec_len(vec), S, A, FLATBUFFERS_COUNT_MAX(S)); }\
static inline N ## _vec_ref_t N ## _vec_slice(NS ## builder_t *B, N ##_vec_t vec, size_t index, size_t len)\
{ size_t n = N ## _vec_len(vec); if (index >= n) index = n; n -= index; if (len > n) len = n;\
  return flatcc_builder_create_vector(B, N ## __const_ptr_add(vec, index), len, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
__flatbuffers_build_vector_ops(NS, N ## _vec, N, N, T)

#define __flatbuffers_build_string_vector_ops(NS, N)\
static inline int N ## _push_start(NS ## builder_t *B)\
{ return NS ## string_start(B); }\
static inline NS ## string_ref_t *N ## _push_end(NS ## builder_t *B)\
{ return NS ## string_vec_push(B, NS ## string_end(B)); }\
static inline NS ## string_ref_t *N ## _push_create(NS ## builder_t *B, const char *s, size_t len)\
{ return NS ## string_vec_push(B, NS ## string_create(B, s, len)); }\
static inline NS ## string_ref_t *N ## _push_create_str(NS ## builder_t *B, const char *s)\
{ return NS ## string_vec_push(B, NS ## string_create_str(B, s)); }\
static inline NS ## string_ref_t *N ## _push_create_strn(NS ## builder_t *B, const char *s, size_t max_len)\
{ return NS ## string_vec_push(B, NS ## string_create_strn(B, s, max_len)); }\
static inline NS ## string_ref_t *N ## _push_clone(NS ## builder_t *B, NS ## string_t string)\
{ return NS ## string_vec_push(B, NS ## string_clone(B, string)); }\
static inline NS ## string_ref_t *N ## _push_slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\
{ return NS ## string_vec_push(B, NS ## string_slice(B, string, index, len)); }

#define __flatbuffers_build_table_vector_ops(NS, N, TN)\
static inline int N ## _push_start(NS ## builder_t *B)\
{ return TN ## _start(B); }\
static inline TN ## _ref_t *N ## _push_end(NS ## builder_t *B)\
{ return N ## _push(B, TN ## _end(B)); }\
static inline TN ## _ref_t *N ## _push_create(NS ## builder_t *B __ ## TN ##_formal_args)\
{ return N ## _push(B, TN ## _create(B __ ## TN ## _call_args)); }

#define __flatbuffers_build_offset_vector_ops(NS, V, N, TN)\
static inline TN ## _ref_t *V ## _extend(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_extend_offset_vector(B, len); }\
static inline TN ## _ref_t *V ## _append(NS ## builder_t *B, const TN ## _ref_t *data, size_t len)\
{ return flatcc_builder_append_offset_vector(B, data, len); }\
static inline int V ## _truncate(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_truncate_offset_vector(B, len); }\
static inline TN ## _ref_t *V ## _edit(NS ## builder_t *B)\
{ return (TN ## _ref_t *)flatcc_builder_offset_vector_edit(B); }\
static inline size_t V ## _reserved_len(NS ## builder_t *B)\
{ return flatcc_builder_offset_vector_count(B); }\
static inline TN ## _ref_t *V ## _push(NS ## builder_t *B, const TN ## _ref_t ref)\
{ return ref ? flatcc_builder_offset_vector_push(B, ref) : 0; }

#define __flatbuffers_build_offset_vector(NS, N)\
typedef NS ## ref_t N ## _vec_ref_t;\
static inline int N ## _vec_start(NS ## builder_t *B)\
{ return flatcc_builder_start_offset_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_end(NS ## builder_t *B)\
{ return flatcc_builder_end_offset_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_create(NS ## builder_t *B, const N ## _ref_t *data, size_t len)\
{ return flatcc_builder_create_offset_vector(B, data, len); }\
__flatbuffers_build_offset_vector_ops(NS, N ## _vec, N, N)

#define __flatbuffers_build_string_ops(NS, N)\
static inline char *N ## _append(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_append_string(B, s, len); }\
static inline char *N ## _append_str(NS ## builder_t *B, const char *s)\
{ return flatcc_builder_append_string_str(B, s); }\
static inline char *N ## _append_strn(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_append_string_strn(B, s, len); }\
static inline size_t N ## _reserved_len(NS ## builder_t *B)\
{ return flatcc_builder_string_len(B); }\
static inline char *N ## _extend(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_extend_string(B, len); }\
static inline char *N ## _edit(NS ## builder_t *B)\
{ return flatcc_builder_string_edit(B); }\
static inline int N ## _truncate(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_truncate_string(B, len); }

#define __flatbuffers_build_string(NS)\
typedef NS ## ref_t NS ## string_ref_t;\
static inline int NS ## string_start(NS ## builder_t *B)\
{ return flatcc_builder_start_string(B); }\
static inline NS ## string_ref_t NS ## string_end(NS ## builder_t *B)\
{ return flatcc_builder_end_string(B); }\
static inline NS ## ref_t NS ## string_create(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_create_string(B, s, len); }\
static inline NS ## ref_t NS ## string_create_str(NS ## builder_t *B, const char *s)\
{ return flatcc_builder_create_string_str(B, s); }\
static inline NS ## ref_t NS ## string_create_strn(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_create_string_strn(B, s, len); }\
static inline NS ## string_ref_t NS ## string_clone(NS ## builder_t *B, NS ## string_t string)\
{ return flatcc_builder_create_string(B, string, NS ## string_len(string)); }\
static inline NS ## string_ref_t NS ## string_slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\
{ size_t n = NS ## string_len(string); if (index >= n) index = n; n -= index; if (len > n) len = n;\
  return flatcc_builder_create_string(B, string + index, len); }\
__flatbuffers_build_string_ops(NS, NS ## string)\
__flatbuffers_build_offset_vector(NS, NS ## string)

#define __flatbuffers_copy_from_pe(P, P2, N) (*(P) = N ## _cast_from_pe(*P2), (P))
#define __flatbuffers_from_pe(P, N) (*(P) = N ## _cast_from_pe(*P), (P))
#define __flatbuffers_copy_to_pe(P, P2, N) (*(P) = N ## _cast_to_pe(*P2), (P))
#define __flatbuffers_to_pe(P, N) (*(P) = N ## _cast_to_pe(*P), (P))
#define __flatbuffers_define_scalar_primitives(NS, N, T)\
static inline T *N ## _from_pe(T *p) { return __ ## NS ## from_pe(p, N); }\
static inline T *N ## _to_pe(T *p) { return __ ## NS ## to_pe(p, N); }\
static inline T *N ## _copy(T *p, const T *p2) { *p = *p2; return p; }\
static inline T *N ## _copy_from_pe(T *p, const T *p2)\
{ return __ ## NS ## copy_from_pe(p, p2, N); }\
static inline T *N ## _copy_to_pe(T *p, const T *p2) \
{ return __ ## NS ## copy_to_pe(p, p2, N); }\
static inline T *N ## _assign(T *p, const T v0) { *p = v0; return p; }\
static inline T *N ## _assign_from_pe(T *p, T v0)\
{ *p = N ## _cast_from_pe(v0); return p; }\
static inline T *N ## _assign_to_pe(T *p, T v0)\
{ *p = N ## _cast_to_pe(v0); return p; }
#define __flatbuffers_build_scalar(NS, N, T)\
__ ## NS ## define_scalar_primitives(NS, N, T)\
__ ## NS ## build_vector(NS, N, T, sizeof(T), sizeof(T))
/* Depends on generated copy_to/from_pe functions, and the type. */
#define __flatbuffers_define_struct_primitives(NS, N)\
static inline N ## _t *N ##_to_pe(N ## _t *p)\
{ if (!NS ## is_native_pe()) { N ## _copy_to_pe(p, p); }; return p; }\
static inline N ## _t *N ##_from_pe(N ## _t *p)\
{ if (!NS ## is_native_pe()) { N ## _copy_from_pe(p, p); }; return p; }\
static inline N ## _t *N ## _clear(N ## _t *p) { return memset(p, 0, N ## __size()); }

/* Depends on generated copy/assign_to/from_pe functions, and the type. */
#define __flatbuffers_build_struct(NS, N, S, A, FID, TFID)\
__ ## NS ## define_struct_primitives(NS, N)\
typedef NS ## ref_t N ## _ref_t;\
static inline N ## _t *N ## _start(NS ## builder_t *B)\
{ return (N ## _t *)flatcc_builder_start_struct(B, S, A); }\
static inline N ## _ref_t N ## _end(NS ## builder_t *B)\
{ if (!NS ## is_native_pe()) { N ## _to_pe(flatcc_builder_struct_edit(B)); }\
  return flatcc_builder_end_struct(B); }\
static inline N ## _ref_t N ## _end_pe(NS ## builder_t *B)\
{ return flatcc_builder_end_struct(B); }\
static inline N ## _ref_t N ## _create(NS ## builder_t *B __ ## N ## _formal_args)\
{ N ## _t *_p = N ## _start(B); if (!_p) return 0; N ##_assign_to_pe(_p __ ## N ## _call_args);\
  return N ## _end_pe(B); }\
__flatbuffers_build_vector(NS, N, N ## _t, S, A)\
__flatbuffers_build_struct_root(NS, N, A, FID, TFID)

#define __flatbuffers_build_table(NS, N, K)\
typedef NS ## ref_t N ## _ref_t;\
static inline int N ## _start(NS ## builder_t *B)\
{ return flatcc_builder_start_table(B, K); }\
static inline N ## _ref_t N ## _end(NS ## builder_t *B)\
{ assert(flatcc_builder_check_required(B, __ ## N ## _required,\
  sizeof(__ ## N ## _required) / sizeof(__ ## N ## _required[0]) - 1));\
  return flatcc_builder_end_table(B); }\
__flatbuffers_build_offset_vector(NS, N)

#define __flatbuffers_build_table_field(ID, NS, N, TN)\
static inline int N ## _add(NS ## builder_t *B, TN ## _ref_t ref)\
{ TN ## _ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ?\
  ((*_p = ref), 0) : -1; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return TN ## _start(B); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, TN ## _end(B)); }\
static inline TN ## _ref_t N ## _create(NS ## builder_t *B __ ## TN ##_formal_args)\
{ return N ## _add(B, TN ## _create(B __ ## TN ## _call_args)); }

#define __flatbuffers_build_union_field(ID, NS, N, TN)\
static inline int N ## _add(NS ## builder_t *B, TN ## _union_ref_t uref)\
{ NS ## ref_t *_p; TN ## _union_type_t *_pt; if (uref.type == TN ## _NONE) return 0; if (uref._member == 0) return -1;\
  if (!(_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1, sizeof(*_pt), sizeof(_pt))) ||\
  !(_p = flatcc_builder_table_add_offset(B, ID))) return -1; *_pt = uref.type; *_p = uref._member; return 0; }\
static inline int N ## _add_type(NS ## builder_t *B, TN ## _union_type_t type)\
{ TN ## _union_type_t *_pt; if (type == TN ## _NONE) return 0; return (_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1,\
  sizeof(*_pt), sizeof(*_pt))) ? ((*_pt = type), 0) : -1; }\
static inline int N ## _add_member(NS ## builder_t *B, TN ## _union_ref_t uref)\
{ NS ## ref_t *p; if (uref.type == TN ## _NONE) return 0; return (p = flatcc_builder_table_add_offset(B, ID)) ?\
  ((*p = uref._member), 0) : -1; }

/* M is the union member name and T is its type, i.e. the qualified name. */
#define __flatbuffers_build_union_member_field(NS, N, NU, M, T)\
static inline int N ## _ ## M ## _add(NS ## builder_t *B, T ## _ref_t ref)\
{ return N ## _add(B, NU ## _as_ ## M (ref)); }\
static inline int N ## _ ## M ## _start(NS ## builder_t *B)\
{ return T ## _start(B); }\
static inline int N ## _ ## M ## _end(NS ## builder_t *B)\
{ return N ## _ ## M ## _add(B, T ## _end(B)); }

/* NS: common namespace, ID: table field id (not offset), TN: name of type T,
 * S: sizeof of scalar type, A: alignment of type T, default value V of type T. */
#define __flatbuffers_build_scalar_field(ID, NS, N, TN, T, S, A, V)\
static inline int N ## _add(NS ## builder_t *B, const T v)\
{ T *_p; if (v == V) return 0; if (!(_p = (T *)flatcc_builder_table_add(B, ID, S, A))) return -1;\
  TN ## _assign_to_pe(_p, v); return 0; }\
static inline int N ## _force_add(NS ## builder_t *B, const T v)\
{ T *_p; if (!(_p = (T *)flatcc_builder_table_add(B, ID, S, A))) return -1;\
  TN ## _assign_to_pe(_p, v); return 0; }\

#define __flatbuffers_build_struct_field(ID, NS, N, TN, S, A)\
static inline TN ## _t *N ## _start(NS ## builder_t *B)\
{ return (TN ## _t *)flatcc_builder_table_add(B, ID, S, A); }\
static inline int N ## _end(NS ## builder_t *B)\
{ if (!NS ## is_native_pe()) { TN ## _to_pe(flatcc_builder_table_edit(B, S)); } return 0; }\
static inline int N ## _end_pe(NS ## builder_t *B) { return 0; }\
static inline int N ## _create(NS ## builder_t *B __ ## TN ## _formal_args)\
{ TN ## _t *_p = N ## _start(B); if (!_p) return 0; TN ##_assign_to_pe(_p __ ## TN ## _call_args);\
 return 0; }\
static inline int N ## _add(NS ## builder_t *B, const TN ## _t *p)\
{ TN ## _t *_p = N ## _start(B); if (!_p) return -1; TN ##_copy_to_pe(_p, p); return 0; }\
static inline int N ## _clone(NS ## builder_t *B, TN ## _struct_t p)\
{ return 0 == flatcc_builder_table_add_copy(B, ID, p, S, A) ? -1 : 0; }

#define __flatbuffers_build_vector_field(ID, NS, N, TN, T)\
static inline int N ## _add(NS ## builder_t *B, TN ## _vec_ref_t ref)\
{ TN ## _vec_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return TN ## _vec_start(B); }\
static inline int N ## _end_pe(NS ## builder_t *B)\
{ return N ## _add(B, TN ## _vec_end_pe(B)); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, TN ## _vec_end(B)); }\
static inline int N ## _create_pe(NS ## builder_t *B, T *data, size_t len)\
{ return N ## _add(B, TN ## _vec_create_pe(B, data, len)); }\
static inline int N ## _create(NS ## builder_t *B, T *data, size_t len)\
{ return N ## _add(B, TN ## _vec_create(B, data, len)); }\
static inline int N ## _clone(NS ## builder_t *B, TN ## _vec_t vec)\
{ return N ## _add(B, TN ## _vec_clone(B, vec)); }\
static inline int N ## _slice(NS ## builder_t *B, TN ## _vec_t vec, size_t index, size_t len)\
{ return N ## _add(B, TN ## _vec_slice(B, vec, index, len)); }\
__flatbuffers_build_vector_ops(NS, N, N, TN, T)

#define __flatbuffers_build_offset_vector_field(ID, NS, N, TN)\
static inline int N ## _add(NS ## builder_t *B, TN ## _vec_ref_t ref)\
{ TN ## _vec_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return flatcc_builder_start_offset_vector(B); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, flatcc_builder_end_offset_vector(B)); }\
static inline int N ## _create(NS ## builder_t *B, const TN ## _ref_t *data, size_t len)\
{ return N ## _add(B, flatcc_builder_create_offset_vector(B, data, len)); }\
__flatbuffers_build_offset_vector_ops(NS, N, N, TN)

#define __flatbuffers_build_string_field(ID, NS, N)\
static inline int N ## _add(NS ## builder_t *B, NS ## string_ref_t ref)\
{ NS ## string_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return flatcc_builder_start_string(B); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, flatcc_builder_end_string(B)); }\
static inline int N ## _create(NS ## builder_t *B, const char *s, size_t len)\
{ return N ## _add(B, flatcc_builder_create_string(B, s, len)); }\
static inline int N ## _create_str(NS ## builder_t *B, const char *s)\
{ return N ## _add(B, flatcc_builder_create_string_str(B, s)); }\
static inline int N ## _create_strn(NS ## builder_t *B, const char *s, size_t max_len)\
{ return N ## _add(B, flatcc_builder_create_string_strn(B, s, max_len)); }\
static inline int N ## _clone(NS ## builder_t *B, NS ## string_t string)\
{ return N ## _add(B, NS ## string_clone(B, string)); }\
static inline int N ## _slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\
{ return N ## _add(B, NS ## string_slice(B, string, index, len)); }\
__flatbuffers_build_string_ops(NS, N)

#define __flatbuffers_build_table_vector_field(ID, NS, N, TN)\
__flatbuffers_build_offset_vector_field(ID, NS, N, TN)\
__flatbuffers_build_table_vector_ops(NS, N, TN)

#define __flatbuffers_build_string_vector_field(ID, NS, N)\
__flatbuffers_build_offset_vector_field(ID, NS, N, NS ## string)\
__flatbuffers_build_string_vector_ops(NS, N)

#define __flatbuffers_uint8_formal_args , uint8_t v0
#define __flatbuffers_uint8_call_args , v0
#define __flatbuffers_int8_formal_args , int8_t v0
#define __flatbuffers_int8_call_args , v0
#define __flatbuffers_bool_formal_args , flatbuffers_bool_t v0
#define __flatbuffers_bool_call_args , v0
#define __flatbuffers_uint16_formal_args , uint16_t v0
#define __flatbuffers_uint16_call_args , v0
#define __flatbuffers_uint32_formal_args , uint32_t v0
#define __flatbuffers_uint32_call_args , v0
#define __flatbuffers_uint64_formal_args , uint64_t v0
#define __flatbuffers_uint64_call_args , v0
#define __flatbuffers_int16_formal_args , int16_t v0
#define __flatbuffers_int16_call_args , v0
#define __flatbuffers_int32_formal_args , int32_t v0
#define __flatbuffers_int32_call_args , v0
#define __flatbuffers_int64_formal_args , int64_t v0
#define __flatbuffers_int64_call_args , v0
#define __flatbuffers_float_formal_args , float v0
#define __flatbuffers_float_call_args , v0
#define __flatbuffers_double_formal_args , double v0
#define __flatbuffers_double_call_args , v0

__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint8, uint8_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int8, int8_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_bool, flatbuffers_bool_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint16, uint16_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint32, uint32_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint64, uint64_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int16, int16_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int32, int32_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int64, int64_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_float, float)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_double, double)

__flatbuffers_build_string(flatbuffers_)

__flatbuffers_build_buffer(flatbuffers_)
#include "flatcc/portable/pdiagnostic_pop.h"
#endif /* FLATBUFFERS_COMMON_BUILDER_H */
#ifndef ECLECTIC_READER_H
#define ECLECTIC_READER_H

/* Generated by flatcc 0.5.0-pre FlatBuffers schema compiler for C by dvide.com */

#ifndef FLATBUFFERS_COMMON_READER_H
#include "flatbuffers_common_reader.h"
#endif
#include "flatcc/flatcc_flatbuffers.h"
#ifndef __alignas_is_defined
#include <stdalign.h>
#endif
#define PDIAGNOSTIC_IGNORE_UNUSED
#include "flatcc/portable/pdiagnostic_push.h"
#undef flatbuffers_identifier
#define flatbuffers_identifier "NOOB"
#ifndef flatbuffers_extension
#define flatbuffers_extension ".bin"
#endif


typedef const struct Eclectic_FooBar_table *Eclectic_FooBar_table_t;
typedef const flatbuffers_uoffset_t *Eclectic_FooBar_vec_t;
typedef flatbuffers_uoffset_t *Eclectic_FooBar_mutable_vec_t;

typedef int8_t Eclectic_Fruit_enum_t;
__flatbuffers_define_integer_type(Eclectic_Fruit, Eclectic_Fruit_enum_t, 8)
#define Eclectic_Fruit_Banana ((Eclectic_Fruit_enum_t)INT8_C(-1))
#define Eclectic_Fruit_Orange ((Eclectic_Fruit_enum_t)INT8_C(42))

static inline const char *Eclectic_Fruit_name(Eclectic_Fruit_enum_t value)
{
    switch (value) {
    case Eclectic_Fruit_Banana: return "Banana";
    case Eclectic_Fruit_Orange: return "Orange";
    default: return "";
    }
}



struct Eclectic_FooBar_table { uint8_t unused__; };

#ifndef Eclectic_FooBar_identifier
#define Eclectic_FooBar_identifier flatbuffers_identifier
#endif
#define Eclectic_FooBar_type_hash ((flatbuffers_thash_t)0xa604f58)
#define Eclectic_FooBar_type_identifier "\x58\x4f\x60\x0a"
static inline size_t Eclectic_FooBar_vec_len(Eclectic_FooBar_vec_t vec)
__flatbuffers_vec_len(vec)
static inline Eclectic_FooBar_table_t Eclectic_FooBar_vec_at(Eclectic_FooBar_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(Eclectic_FooBar_table_t, vec, i, 0)
__flatbuffers_table_as_root(Eclectic_FooBar)

__flatbuffers_define_scalar_field(0, Eclectic_FooBar, meal, Eclectic_Fruit, Eclectic_Fruit_enum_t, INT8_C(-1))
/* Skipping deprecated field: 'Eclectic_FooBar_density' */

__flatbuffers_define_string_field(2, Eclectic_FooBar, say, 0)
__flatbuffers_define_scalar_field(3, Eclectic_FooBar, height, flatbuffers_int16, int16_t, INT16_C(0))

#include "flatcc/portable/pdiagnostic_pop.h"
#endif /* ECLECTIC_READER_H */
#ifndef ECLECTIC_BUILDER_H
#define ECLECTIC_BUILDER_H

/* Generated by flatcc 0.5.0-pre FlatBuffers schema compiler for C by dvide.com */

#ifndef ECLECTIC_READER_H
#include "eclectic_reader.h"
#endif
#ifndef FLATBUFFERS_COMMON_BUILDER_H
#include "flatbuffers_common_builder.h"
#endif
#define PDIAGNOSTIC_IGNORE_UNUSED
#include "flatcc/portable/pdiagnostic_push.h"
#undef flatbuffers_identifier
#define flatbuffers_identifier "NOOB"
#ifndef flatbuffers_extension
#define flatbuffers_extension ".bin"
#endif

#define __Eclectic_Fruit_formal_args , Eclectic_Fruit_enum_t v0
#define __Eclectic_Fruit_call_args , v0
__flatbuffers_build_scalar(flatbuffers_, Eclectic_Fruit, Eclectic_Fruit_enum_t)

static const flatbuffers_voffset_t __Eclectic_FooBar_required[] = { 0 };
__flatbuffers_build_table(flatbuffers_, Eclectic_FooBar, 4)
#define __Eclectic_FooBar_formal_args , Eclectic_Fruit_enum_t v0, flatbuffers_string_ref_t v2, int16_t v3
#define __Eclectic_FooBar_call_args , v0, v2, v3
static inline Eclectic_FooBar_ref_t Eclectic_FooBar_create(flatbuffers_builder_t *B __Eclectic_FooBar_formal_args);

__flatbuffers_build_scalar_field(0, flatbuffers_, Eclectic_FooBar_meal, Eclectic_Fruit, Eclectic_Fruit_enum_t, 1, 1, INT8_C(-1))
/* Skipping build of deprecated field: 'Eclectic_FooBar_density' */

__flatbuffers_build_string_field(2, flatbuffers_, Eclectic_FooBar_say)
__flatbuffers_build_scalar_field(3, flatbuffers_, Eclectic_FooBar_height, flatbuffers_int16, int16_t, 2, 2, INT16_C(0))

static inline Eclectic_FooBar_ref_t Eclectic_FooBar_create(flatbuffers_builder_t *B __Eclectic_FooBar_formal_args)
{
    if (Eclectic_FooBar_start(B)
        || Eclectic_FooBar_say_add(B, v2)
        || Eclectic_FooBar_height_add(B, v3)
        || Eclectic_FooBar_meal_add(B, v0)) {
        return 0;
    }
    return Eclectic_FooBar_end(B);
}
__flatbuffers_build_table_prolog(flatbuffers_, Eclectic_FooBar, Eclectic_FooBar_identifier, Eclectic_FooBar_type_identifier)

#include "flatcc/portable/pdiagnostic_pop.h"
#endif /* ECLECTIC_BUILDER_H */
#ifndef ECLECTIC_VERIFIER_H
#define ECLECTIC_VERIFIER_H

/* Generated by flatcc 0.5.0-pre FlatBuffers schema compiler for C by dvide.com */

#ifndef ECLECTIC_READER_H
#include "eclectic_reader.h"
#endif
#include "flatcc/flatcc_verifier.h"
#define PDIAGNOSTIC_IGNORE_UNUSED
#include "flatcc/portable/pdiagnostic_push.h"

static int __Eclectic_FooBar_table_verifier(flatcc_table_verifier_descriptor_t *td);

static int __Eclectic_FooBar_table_verifier(flatcc_table_verifier_descriptor_t *td)
{
    int ret;
    if ((ret = flatcc_verify_field(td, 0, 1, 1) /* meal */)) return ret;
    if ((ret = flatcc_verify_string_field(td, 2, 0) /* say */)) return ret;
    if ((ret = flatcc_verify_field(td, 3, 2, 2) /* height */)) return ret;
    return flatcc_verify_ok;
}

static inline int Eclectic_FooBar_verify_as_root(const void *buf, size_t bufsiz)
{
    return flatcc_verify_table_as_root(buf, bufsiz, Eclectic_FooBar_identifier, &__Eclectic_FooBar_table_verifier);
}

static inline int Eclectic_FooBar_verify_as_typed_root(const void *buf, size_t bufsiz)
{
    return flatcc_verify_table_as_root(buf, bufsiz, Eclectic_FooBar_type_identifier, &__Eclectic_FooBar_table_verifier);
}

static inline int Eclectic_FooBar_verify_as_root_with_identifier(const void *buf, size_t bufsiz, const char *fid)
{
    return flatcc_verify_table_as_root(buf, bufsiz, fid, &__Eclectic_FooBar_table_verifier);
}

static inline int Eclectic_FooBar_verify_as_root_with_type_hash(const void *buf, size_t bufsiz, flatbuffers_thash_t thash)
{
    return flatcc_verify_table_as_typed_root(buf, bufsiz, thash, &__Eclectic_FooBar_table_verifier);
}

#include "flatcc/portable/pdiagnostic_pop.h"
#endif /* ECLECTIC_VERIFIER_H */
